# SMC代码学习

下载地址：https://github.com/seclabBupt/aiacc.git

## 1 IEEE 754

IEEE 754标准是现代计算机系统表示和处理浮点数的事实国际标准。它定义了浮点数的二进制格式、运算规则、舍入方式以及特殊值的处理（如无穷大、NaN）。

IEEE 754浮点数本质上是用二进制的形式表示科学计数法：数值 = 符号  (1 + 尾数)  2^(指数 - 偏移量)

它由三个关键部分组成：

符号位:占据最高位（最左边的一位）。0表示正数,1表示负数。

指数部分:存储在符号位之后。长度和偏移量取决于具体格式（单精度、双精度等）。表示二进制小数点需要移动的位置数。为了能表示负指数，引入了偏移量(Bias)。真正的指数值是E的值减去这个偏移量(exp = E - bias)。

尾数/有效数字:存储在指数部分之后，占据剩余的位。表示二进制小数部分。在规约数（大部分正常数）中，尾数有一个隐含的前导位 1（即实际尾数是 1.M）。这意味着你不需要存储1本身，节省了一个比特位。例如，如果 M 是 01011...，实际的尾数值是 1.01011...。

非规约数是一个特殊情况（指数域全为0），用于表示非常接近0的数。此时没有隐含的1，实际尾数值是 0.M，并且指数固定为 1 - bias（而不是 0 - bias），这样可以更平滑地过渡到零。

主要格式规格
|格式|总比特数|符号位(S)|指数位(E)|尾数位(M)|偏移量(bias)|隐含位|
|-----|---|---|---|---|---|---|
|单精度|32位|1位|8位|23位|127|1|
|双精度|64位|1位|11位|52位|1023|1|

特殊值处理（当指数域 E 为特定值时）

E = 全0 (000...0):

如果 M = 0 ,则表示±0（具体是+0还是-0由符号位S决定）。

如果 M ≠ 0 ,则表示非规约数。数值 = (-1)^S * 0.M * 2^(1 - bias)。

E = 全1 (111...1):

如果 M = 0, 则表示 ±∞ （+Infinity 或 -Infinity，由 S 决定）。由如除以0、溢出等产生。

如果 M ≠ 0, 则表示 非数 (NaN - Not a Number)。表示无效的操作结果（如 0/0, √(-1), ∞ - ∞）。NaN 分为 Quiet NaN (qNaN，通常用于传播) 和 Signaling NaN (sNaN，通常用于触发异常)，通过 M 中的特定模式区分。无论 S 是什么，NaN 通常被简单地称为 NaN。

舍入模式

IEEE 754 定义了多种舍入方式（舍入到最近值，舍入到正无穷大，舍入到负无穷大，舍入到0），以确保计算的可预测性。

### 示例 1：将十进制数 42.125 转换为 IEEE 754 单精度浮点数

确定符号： 正数，所以 S = 0。

转换为二进制：

整数部分: 42 / 2 = 21 余 0, 21 / 2 = 10 余 1, 10 / 2 = 5 余 0, 5 / 2 = 2 余 1, 2 / 2 = 1 余 0, 1 / 2 = 0 余 1。读取余数从下往上：101010。

小数部分: 0.125  2 = 0.25 -> 0, 0.25 * 2 = 0.5 -> 0, 0.5 * 2 = 1.0 -> 1。读取整数部分从上到下：001。

完整的二进制：101010.001。

规格化： 将二进制小数点左移 5 位，使其左边只有一个 1：101010.001 = 1.01010001 * 2^5。

提取尾数 (M): 移除隐含的1，只取小数部分 .01010001。由于单精度有 23 位，我们在右边补 0 直到填满 23 位：M = 01010001000000000000000。

计算指数 (E): exp = 5，单精度的偏移量 bias = 127。E = exp + bias = 5 + 127 = 132。

将指数转换为二进制： 132 / 2 = 66 余 0, 66 / 2 = 33 余 0, 33 / 2 = 16 余 1, 16 / 2 = 8 余 0, 8 / 2 = 4 余 0, 4 / 2 = 2 余 0, 2 / 2 = 1 余 0, 1 / 2 = 0 余 1。读取余数从下往上：10000100。

组合各部分：

S (1位) = 0

E (8位) = 10000100

M (23位) = 01010001000000000000000

完整的32位：0 10000100 01010001000000000000000
十六进制表示： 方便查看内存中的值。

分组：0100 0010 0010 1000 1000 0000 0000 0000

十六进制：4 2 2 8 8 0 0

 0 -> 0x42288000

### 示例 2：将十进制数 -0.75 转换为 IEEE 754 单精度浮点数

确定符号： 负数，所以 S = 1。

转换为二进制：

整数部分: 0 -> 0。

小数部分: 0.75  2 = 1.5 -> 1, 0.5  2 = 1.0 -> 1, 0.0 * 2 = 0。读取整数部分从上到下：11。

完整的二进制：0.11。
规格化： 将二进制小数点右移 1 位：0.11 = 1.1 * 2^(-1)。(向右移动等价于乘以 2，所以要乘以 2^{-1} 来抵消移动效果)。

提取尾数 (M): 移除隐含的1，只取小数部分 .1。在右边补 0 直到填满 23 位：M = 10000000000000000000000。

计算指数 (E): exp = -1，单精度的偏移量 bias = 127。E = exp + bias = -1 + 127 = 126。

将指数转换为二进制： 126 / 2 = 63 余 0, 63 / 2 = 31 余 1, 31 / 2 = 15 余 1, 15 / 2 = 7 余 1, 7 / 2 = 3 余 1, 3 / 2 = 1 余 1, 1 / 2 = 0 余 1。读取余数从下往上：01111110。

组合各部分：

S (1位) = 1

E (8位) = 01111110

M (23位) = 10000000000000000000000

完整的32位：1 01111110 10000000000000000000000
十六进制表示：

分组：1011 1111 0100 0000 0000 0000 0000 0000

十六进制：B F 4 0 0 0
 0 -> 0xBF400000

## 2 compile_softfloat_dpi.sh

这个脚本是一个用于自动化编译和链接 ​​SoftFloat DPI-C 接口库​​ 的 Bash 脚本。


