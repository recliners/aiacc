# Verilog 学习心得

本人为初学者，此为Verilog 的入门心得，来自于一边学习一边记录，如有错误，还请指正.

## 1 Verilog介绍

**Verilog** 是一种​​硬件描述语言​​，主要用于​​设计和模拟数字电路和系统​​。它是电子设计自动化领域的基石之一（与 VHDL 并列为两大主流 HDL），在芯片设计（ASIC）、现场可编程门阵列设计（FPGA）、以及复杂的数字系统设计中扮演着核心角色。

## 2 数值表示

在verilog中的数值表示方式通常为 **<位宽>'<基数><数值>**，如 **4'b1011**。以下对该表示方式的各个参数进行解释。

**位宽​**是数字电路和计算机系统中的核心概念，指的是​​一个数字信号用多少位（bit）二进制数来表示​​。它直接决定了该信号能表示的​​数值范围、精度和分辨率​​。信号的位宽取决于要该信号要表示的最大值。该信号能表示的无符号数最大值是：2^n-1，其中n表示该信号的位宽。例如，信号a的最大值为100，其二进制为1100110，那么信号a的位宽必须大于或等于7位。

**基数​**是表示数字是多少进制的。常用的进制数为二进制（b或B）、十进制（d或D）、八进制（o或O）和十六进制（h或H）。

**数值**是由基数所决定的表示常量真实值的一串ASCII码。如果基数定义为b或B，数值可以是0，1，x，X，z或Z。如果基数定义为o或O，数值是0-7。如果基数定义为h或H，数值是0-F。对于基数为d或者D的情况，数值是0-9。例如，4'b12是错误的，因为b表示二进制，数值只能是0、1、x或者z，不包含2。32'h12等同于32'h00000012，即数值未写完整时，高位置补0。

**补充**：32'h00000012中h为十六进制，每一位相当于四位二进制，因此位宽为32，数值前面只补六个0。

## 3 数据类型

在Verilog中，数据类型分为三种，分别为寄存器类型，线网类型，参数类型（非线路类型）。其中主要使用的是前两种。

**寄存器类型**通常用reg来对储存单元进行描述。如D型触发器、ROM等。寄存器类型信号的特点是在某种触发机制下分配了一个值，在下一触发机制到来之前保留原值。
通过赋值语句可以改变寄存器中储存的值。
```verilog
reg [31:0] cnt; //位宽32位的寄存器
reg [32:0] cnt1,cnt2,cnt3; //三个位宽为32位的寄存器
```
它可以在always语句和initial语句中使用。
如果该过程语句描述的是时序逻辑，即always语句（后续会解释何为always语句）带有时钟信号，则该寄存器变量对应为寄存器；如果该过程语句描述的是组合逻辑，即always语句不带有时钟信号，则该寄存器变量对应为硬件连线；

**线网类型**通常用wire关键字说明线网类型，它代表元件间的物理连线。它的值由驱动元件的值决定如果没有驱动元件连接到线网，线网的缺省值为z（高阻态）。
```verilog
wire [3:0] Sat; // Sat为4位线型信号
wire Cnt; // Cnt为1位线型信号
wire [31:0] A, B, C;// A,B,C都是32位的线型信号
```
由于线网类型代表的是物理连接线，因此其不存储逻辑值，必须由器件驱动。通常用assign进行赋值，如 
```verilog
wire [3:0] B,C;
wire [4:0] A;
assign A = B + C;
```
没有定义信号数据类型时，缺省为wire类型。

reg型信号并不一定生成寄存器。针对什么时候使用wire类型，什么时候用reg类型这一问题给出的建议是，在本模块中使用always设计的信号都定义为reg型，其他信号都定义为wire型。
例如：
```verilog
always @(posedge clk or negedge rst_n) begin
    if (rst_n==0) begin
        cnt1 <= 0; 
    end
    else if(add_cnt1) begin
        if(end_cnt1)
            cnt1 <= 0;
        else
            cnt1 <= cnt1 + 1; 
        end
    end
assign add_cnt1 = end_cnt0;
assign end_cnt1 = add_cnt1 && cnt1 == 8-1;
```
上述代码中，cnt1是用always设计的，所以定义为reg型。add_cnt1和end_cnt不是由always产生的，所以定义为wire型。

## 4 赋值方式

verilog中赋值方式有三种，分别是连续赋值、阻塞赋值和非阻塞赋值。

**连续赋值**用assign表示。
```verilog
assign add_cnt1 = end_cnt0;
```
该代码就表示将end_cnt0的值赋给add_cnt1。注意，连续赋值不能在always内部使用，不许放在always的的外部。

**阻塞赋值**用“=”表示，在一个“begin...end”的多行赋值语句，先执行当前行的赋值语句，再执行下一行的赋值语句。常用于组合always块中。

**非阻塞赋值**用“<=”表示,在一个“begin...end”的多行赋值语句，在同一时间内同时赋值。常用于时序always块中。

先解释一下两者在赋值顺序方面的区别：
```verilog
begin
    c1 = a;
    d1 = c1 + a; 
end

begin
    c2 <= a;
    d2 <= c2 + a; 
end
```
假设a的初始值为1，c1和c2的初始值都为0。
对d1的取值进行描述。因为“=”表示先执行第一行的代码，再执行第二行的代码，所以c1=a=1,d1=c1+a=2。

对d2的取值进行描述。因为“<=”表示同一时间同时赋值，因此d2=c2+a与c2=a同时进行，此时d2=c2+a的c2还是原来的值0，所以d2=1,同时把a的值幅值给c2，所以c2=1，d2=1。

对于组合always块和时序always块，下一节做出详细解释。

## 5 always逻辑块

always块可构建组合逻辑块和时序逻辑块，复杂的逻辑操作都需要处于该逻辑块中，如if、case、for等。
接下来讲解一下组合和时序的区别：
![example picture](/images/D-Flip-Flop.png)
<div style="text-align: center;">
D触发器图片
</div>

该图为一个D触发器的结构图，可以将其视为一个芯片，该芯片拥有4个管脚，其中3个是输入管脚：时钟clk、复位rst_n、信号d；1个是输出管脚：q。
该芯片的功能如下：当给管脚rst_n给低电平，即赋值为0 时，输出管脚q处于低电平状态。如果管脚rst_n为高电平，则观察管脚clk的状态，当clk信号由0变1即处于上升沿的时候，将此时d的值赋给q。

```verilog
//时序always块
always @(posedge clk or negedge rst_n)begin
    if(rst_n==1'b0)begin
        q <= 0;
    end
    else  begin
        q <= d;
    end 
end
```

```verilog
//组合always块
always @(a or b or d or sel)begin
	if(sel==0)
        c = a + b; 
    else
        c = a + d; 
end
```
第一段代码为时序always块，当检测到时钟信号的上升沿或者复位信号的下降沿时执行一次该代码，具体执行方式为：
如果 rst_n=0，则 q 的值为 0；
如果 rst_n=1，则将 d 的值赋给 q；
这个功能与D触发器的描述相似，可以用来表示D触发器。

第二段代码为组合always块，当a或b或d或sel发生变化时就执行一次该代码，具体执行方式为：
如果 sel=0，则c=a+b;
如果 sel=1，则c=a+d;

总的来说，时序always块和组合always块的区别就在于时序块中当posedge（上升沿）或negedge（下降沿）时才可以触发，而组合块中括号内信号变化时立即触发。

## 6 基础语法

### 6.1 逻辑值

Verilog中有4中逻辑值：0、1、x、z。

x态，称之为不定态，其常用于判断条件，从而告诉综合工具设计者不关心它的电平是多少，是0还是1都可以。

z态，一般称之为高阻态，表示设计者不驱动这个信号（既不给0也不给1），通常用于三态门接口当中。

注：这里的z、x是不区分大小写的。

### 6.2 运算

运算包括逻辑运算、按位运算移位运算等，当然还有一些其他的运算，不过暂时还未学到，留到后续再进行学习和补充。

**逻辑运算**包括&&(与)、==（相等）、||（或）、!=（不等）。如m&&n，其表示判断m和n是否全为真(非0即为真)，真则输出1'b1，否则输出1'b0，例如:
m=4’b1010&,n=4’b0101=1’b1，则m&&n=1'b1,最后输出结果只有1bit。
**按位运算**包括&（与）、|（或）、~（非）等。

以下是按位与的真值表:

| 与 | 0 | 1 | x | z |
|---|---|---|---|--|
| 0 | 0 | 0 | 0 | 0 |
| 1 | 0 | 1 | x | x |
| x | 0 | x | x | x |
| z | 0 | x | x | x |

以下是按位或的真值表:

| 或 | 0 | 1 | x | z |
|---|---|---|---|--|
| 0 | 0 | 1 | x | x |
| 1 | 1 | 1 | 1 | 1 |
| x | x | 1 | x | x |
| z | x | 1 | x | x |

**移位运算**包括左移（<<），右移（>>），算术左移（<<<），算术右移（>>>）。移位操作符是双目操作符，两个操作数分别表示要进行移位的向量信号（操作符左侧）与移动的位数（操作符右侧）。算术左移和逻辑左移时，右边低位会补0。逻辑右移时，左边高位会补0；而算术右移时，左边高位会补充符号位，以保证数据缩小后值的正确性。
```verilog
A = 4'b1100 ;
B = 4'b0010 ;
A = A >> 2 ;        //结果为 4'b0011
A = A << 1;         //结果为 4'b1000
A = A <<< 1 ;       //结果为 4'b1000
C = B + (A>>>2);    //结果为 2 + (-4/4) = 4'b0001
```

左移n位相当于乘2^n，右移n位相当于除以2^n。对于算数运算，可以在此进行解释。

A = 4'b1100;为算数运算，那么第一位为符号位，1为负，100为补码，则原码为补码取反加一，为100，等于4，所以A = -4；右移两位，等价于除以4，结果为-1，最终算出C = 1。

### 6.3 三元表达

**三元表达**与C语言相同，其基本表示为
```verilog
condition ? if_true : if_false
```
当条件为真，表达式值为if_true，否则表达式值为if_false。

### 6.4 if-else

verilog的if-else与C语言的相同，其具体用法举个例子就可以明白。
```verilog
if(Sum < 60)  begin
    Grade = C;
    Total_C = Total _C + 1; 
end
else if(Sum < 75)  begin
    Grade = B;
    Total_B = Total_B + 1; 
end
else begin
    Grade = A;
    Total_A = Total_A + 1; 
end
```

### 6.5 case

verilog中的case也与C语言中的类似，其具体用法为：
```verilog
case(<控制表达式>)
    <分支语句 1> : 语句块 1;
    <分支语句 2> : 语句块 2;
    <分支语句 3> : 语句块 3;
    ………
    <分支语句 n> : 语句块 n;
 
    default : 语句块 n+1;
endcase
```





